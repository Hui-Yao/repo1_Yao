#!/usr/bin/env python
#-*- coding:utf-8 -*-
# Author = "Hui_Yao"

'''装饰器
定义：装饰器的本质就是函数（器就是函数的意思）。装饰器是用来装饰其他函数的函数，用来给其他函数增加新功能。
原则：1.不修改其他函数源代码
     2.不修改其他函数的调用方式

实现装饰器的知识储备：
1.函数即变量
    1.1 x=1  #执行该语句的过程为：在内存中划出一块区域，将数据1存入，将变量x指向数据1的地址，这样在程序中就能通过x找到1.

    1.2 def fun():     #执行该fun（）函数定义程序段的过程为：在内存中划出一块区域，将数据’函数体‘存入(就是存入一段字符串)，
            '函数体'    #将函数名（变量）fun指向’函数体‘的地址，这样在程序中就能通过fun找到’函数体‘.
        1.2.1 匿名函数lambda，是没有变量名的，这意味着当该函数调用完后其内存空间就会被释放。
              但是可以将之复制给一个变量，给这个匿名函数加上一个引用，加上一个门牌号。
2.高阶函数
定义：1.将函数名作为实参传给a函数(可实现在不修改被装饰函数源代码的前提下为函数增加新功能，但是其调用方式会被改变)
     2.a函数的返回值中含有函数名（可实现不改变函数的调用方式）
满足以上两个条件之一，都可以将a成为高阶函数

3.嵌套函数：在一个函数内部用def定义一个新的函数，而不是调用别的函数
特别注意：嵌套函数的子函数，在哪一层定义就要在哪一层调用一下，不然子函数无效



高阶函数+嵌套函数



'''

#高阶函数——将函数名作为参数传入
# def hello():
#     print('hello')
#
# def world(args):
#     print(args)
#     args()
#
#     happy = args
#     print(happy)
#     happy()
#
#
# print(hello)
# world(hello)
'''
再次理解函数即变量：
    定义了hello函数，即将hello的函数提存入了内存中，在让hello指向该地址，输出hello，得到了该函数体的内存地址，
也即变量hello等于其函数体的内存地址。
    将hello作为实参传给world（）函数，也即将hello（）函数的函数体内存地址传给了参数args，args与hello指向同一内存地址，
hello == args，则hello（） == args（）。
    同样hello的值也可以赋值给别的变量（happy），则hello（） == happy（）

'''

# g = 0
# def grandpa():
#     g = 1
#     def dad():
#         g = 2
#         def son():
#             g = 3
#             print(g)
#         son()
#     dad()
#
# grandpa()

g = 0
def grandpa():
    g = 1
    def dad():
        g = 2
        print(g)
    print('dad函数的内存地址：',dad)    #此时dad函数已经定义了
    # dad()

grandpa()




'''
嵌套函数中的子函数，在哪一层定义的，就一定要在哪一层调用，否则盖子函数将无效。
分析上面例子：在grandpa中定义了dad，dad是个局部变量，在程序顶层无法调用，在dad内部不能调用（调试下会发现进下一层），
所以嵌套函数的子函数，在那一层定义就要在哪一层调用。
'''

